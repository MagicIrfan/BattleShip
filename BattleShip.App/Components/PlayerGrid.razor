@inject IGameService GameService
@inject IJSRuntime JsRuntime

<div class="grid" @onmousemove="OnMouseMoveHandler" @onwheel="OnMouseWheelHandler" @ref="playerGridRef">
    @for (int row = 0; row < GameService.playerGrid.Positions.Length; row++)
    {
        @for (int col = 0; col < GameService.playerGrid.Positions[0].Length; col++)
        {
            var currentRow = row;
            var currentCol = col;

            Position playerPosition = GameService.playerGrid.Positions[col][row];

            bool boatPresent = GameService.IsBoatAtPosition(playerPosition);
            string cellBackgroundColor = boatPresent ? "lightgray" : "";

            bool isHighlighted = IsHighlighted(row, col);

            <button @onclick="OnMouseClickHandler" @ref="cellRef" class="cell"
                    style="background-color: @(cellBackgroundColor);
                               @(IsHighlighted(row, col) ? "outline: 2px solid yellow;" : "");
                               @(ArePositionsOverlapping(mouseRow, mouseCol, isVertical, sizes[indexBoat]) && IsHighlighted(row, col) ? "outline: 2px solid red;" : "")">
            </button>
        }
    }
</div>

@code {
    [Parameter]
    public Position[][] Positions { get; set; }
    bool isPlacingBoats = true;
    bool isVertical = false;
    int size = 5;
    int indexBoat = 0;
    int gridSize = 10;
    IList<int> sizes = new List<int> { 2, 3, 3, 4, 5 };

    int mouseRow = -1;
    int mouseCol = -1;
    ElementReference playerGridRef;
    ElementReference cellRef;
    double gridX = 0, gridY = 0;

    public async Task PlaceBoat(MouseEventArgs e)
    {
        if (isPlacingBoats)
        {
            if (gridX == 0 && gridY == 0)
            {
                var rect = await JsRuntime.InvokeAsync<BoundingClientRect>("getGridBoundingRect", playerGridRef);
                gridX = rect.Left;
                gridY = rect.Top;
            }

            var cellSize = await JsRuntime.InvokeAsync<int>("getCellSize", cellRef);

            int relativeX = (int)(e.ClientX - gridX);
            int relativeY = (int)(e.ClientY - gridY);

            mouseRow = relativeY / cellSize;
            mouseCol = relativeX / cellSize;

            if (mouseRow < 0 || mouseRow >= gridSize || mouseCol < 0 || mouseCol >= gridSize)
            {
                mouseRow = -1;
                mouseCol = -1;
            }
        }
    }

    public async Task OnMouseMoveHandler(MouseEventArgs e)
    {
        await PlaceBoat(e);
    }

    private bool ArePositionsOverlapping(int mouseRow, int mouseCol, bool isVertical, int boatSize)
    {
        List<Position> newPositions = new List<Position>();
        for (int i = 0; i < boatSize; i++)
        {
            Position position;
            if (isVertical)
            {
                position = new Position(mouseCol, mouseRow + i);
            }
            else
            {
                position = new Position(mouseCol + i, mouseRow);
            }
            newPositions.Add(position);
        }

        foreach (var boat in GameService.boats)
        {
            foreach (var existingPosition in boat.Positions)
            {
                foreach (var newPosition in newPositions)
                {
                    if (existingPosition.X == newPosition.X && existingPosition.Y == newPosition.Y)
                    {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    public async void OnMouseClickHandler(MouseEventArgs e)
    {
        if (isPlacingBoats)
        {
            if (CanPlaceBoat())
            {
                int size = sizes[indexBoat];
                List<Position> boatPositions = new List<Position>();
                for (int i = 0; i < size; i++)
                {
                    Position position;
                    if (isVertical)
                    {
                        position = new Position(mouseCol, mouseRow + i);
                    }
                    else
                    {
                        position = new Position(mouseCol + i, mouseRow);
                    }
                    boatPositions.Add(position);
                }

                if (ArePositionsOverlapping(mouseRow, mouseCol, isVertical, size))
                {
                    Console.WriteLine("Les bateaux se chevauchent !");
                    return;
                }

                GameService.PlaceBoat(boatPositions);

                if (indexBoat == 4)
                {
                    isPlacingBoats = false;
                    await GameService.PlaceBoats();
                }
                else
                {
                    indexBoat += 1;
                }
            }
        }
    }

    public void OnMouseWheelHandler(WheelEventArgs e)
    {
        isVertical = !isVertical;
    }

    private bool IsHighlighted(int row, int col)
    {
        if (mouseRow == -1 || mouseCol == -1) return false;

        return isPlacingBoats && CanPlaceBoat() &&
               ((isVertical && col == mouseCol && row >= mouseRow && row < mouseRow + sizes[indexBoat]) ||
               (!isVertical && row == mouseRow && col >= mouseCol && col < mouseCol + sizes[indexBoat]));
    }

    private bool CanPlaceBoat()
    {
        if (isVertical)
        {
            return mouseRow >= 0 && mouseRow + sizes[indexBoat] - 1 < gridSize;
        }
        else
        {
            return mouseCol >= 0 && mouseCol + sizes[indexBoat] - 1 < gridSize;
        }
    }

    public class BoundingClientRect
    {
        public double Top { get; set; }
        public double Left { get; set; }
        public double Width { get; set; }
        public double Height { get; set; }
    }
}

<script>
    window.getGridBoundingRect = function (gridElement) {
        if (!gridElement) return null;
        return gridElement.getBoundingClientRect();
    };
    window.getCellSize = function (cellElement) {
        if (!cellElement) return null;
        const style = getComputedStyle(cellElement);
        return parseInt(style.width);
    };
</script>

<style>
    .grid {
        display: grid;
        grid-template-columns: repeat(10, 1fr);
        grid-template-rows: repeat(10, 1fr);
        gap: 5px;
        background-color: #dce7f1;
        padding: 10px;
        border-radius: 10px;
        box-shadow: 0 8px 16px rgba(0, 0, 0, 0.1);
    }

    .cell {
        width: 40px;
        height: 40px;
        border: 1px solid #b0c4de;
        border-radius: 4px;
        position: relative;
    }

        .cell:not([disabled]):hover {
            background-color: #7fc9ff;
        }

        .cell:not([disabled]) {
            cursor: pointer;
            transition: transform 0.2s, background-color 0.2s;
        }

    .boat-symbol {
        font-weight: bold;
        color: darkblue;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
    }
</style>